# Hash Table

## Hash란

해쉬는 내부적으로 베열을 사용하여 데이터를 저장하기 때문에 탐색에 무척 빠르다. 특정한 값에 대해 인덱스 접근을 하게 되므로 O(1)의 시간이 걸린다. 물론 항상 O(1)은 아니고, Hash 함수에 대해 중복이 있을 경우 충돌로 인해 시간이 더 소요된다.

Hash는 특별한 알고리즘을 사용하여 저장할 데이터를 연관된 고유 숫자로 바꾸어 인덱스로 사용한다. 

## Hash Function

이때 특별한 알고리즘에 의해 반환된 고유 값을 해쉬코드라고 하며, 저장되는 값들의 키값을 작은 범위의 값들로 바꿔준다.

하지만 해쉬함수를 통해 키값을 결정했을때 중복된 값이 도출될 수 있다. 이렇게 되면 동일한 키값에 복수의 데이터가 테이블에 존재하는데 이것을 Collision 이라고 한다. 

### 좋은 해쉬함수의 조건

일반적으로 좋은 해쉬함수는 키의 일부를 참조하는 것이 아닌 키 전체를 참조해 해쉬값을 만들어 낸다. 해쉬함수는 무조건 1:1로 만드는 것보다 충돌을 최소화하고 충돌에 대비해 어떻게 대응할지가 더 중요하다. 1:1 대응이 되도록 만드는 것은 불가능하기도 하고 그렇게 만들어 봤자 그냥 배열과 다를것이 없어 메모리를 너무 차지하기 때문이다.

충돌이 많아질수록 필요한 시간복잡도가 1 에서 n에 가까워진다. 

해싱된 인덱스에 이미 다른 값이 있다면 새 데이터를 저장할 다른 위치를 찾은 뒤에야 저장할 수 있다. 따라서 충돌 해결은 필수이다.



## 충돌(Collision) 해결 방법

기본적으로 두 가지 방법이 있다.

### 1. Open Address 방식(개방주소법)

해시 충돌이 발생했을때, 다른 해시 버킷에 해당 자료를 삽입하는 방식, 이 알고리즘은 충돌이 발생하였을때 데이터를 저장할 장소를 찾아 헤맨다. 이 과정도 여러 방법이 존재하는데,

1) Linear Probing  순차적으로 탐색하여 빈 버킷을 찾는다.

2) Quadratic Probing 2차 함수를 사용하여 탐색 위치를 찾는다

3) Double hashing probing : 하나의 해쉬 함수에서 충돌이 발생하면 2차 해쉬함수를 이용해 새로운 주소를 할당.



### 2. 분리 연결법(Separate Chaining)

일반적으로 개방주소법은은 분리 연결법에 비해 느리다. 개방주소는 해시버킷의 밀도가 높아질수록 시간 복잡도가 높아지기 때문, 하지만 분리 연결법은 보조 해시 함수를 통해 그 복잡도를 줄일 수 있다. 자바에서는 분리 연결법을 사용해 해시맵을 구현하고 있다. 2가지 방법이 있다.

1) 연결리스트를 통해 구현하는 방식 

충돌이 발생하였을때 각각의 버킷을 연결리스트로 만들어 충돌이 발생하면 해당 버킷의 연결리스트에 이어 붙이는 방식으로 삭제 삽입이 간단하다. 하지만 단점도 그대로 물려받아 적은 데이터를 저장할때 연결 리스트 자체의 오버헤드가 부담이 된다. 

2) Tree를 사용하는 방식

Red-Black Tree를 사용하는 방식으로 연결리스트 대신 트리를 사용하는 방식, Linked list를 쓸지 RBT를 쓸지 구분하는 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수이다. 데이터 수가 적으면 링크드 리스트, 트리는 기본적인 메모리 사용량이 많기 때문. 키-값 쌍의 수가 6개, 8개를 기준으로 결정한다.



### Open Address VS Separate Chaining

두 방법 모두 최악의 경우 O(M), 하지만 개방 주소법은 연속된 공간에 데이터를 저장하기 때문에 분리연결법에 비해 캐시 효율이 높다. 데이터 수가 적다면 개방주소법이 더 좋다. 또한 개방주소법은 버킷을 계속해서 사용하여  테이블의 확장을 늦출 수 있다.



## 해시 버킷 동적 확장(Resize)

해시 버킷의 개수가 적으면 메모리를 아낄 수 있지만 충돌로 인해 성능 손실이 발생한다. 그래서 특정 개수 이상이 되면 버킷의 개수를 두 배로 늘린다. 해시 버킷을 두배로 확장하는 임계는 현재 데이터 개수가 버킷의 개수의 75프로가 될 때이다. Load factor라고 불린다.