# 스케줄러

프로세스를 스케쥴링하기 위한 Queue에는 세 가지 종류가 있다.

Job Queue : 현재 시스템 내 있는 모든 프로세스의 집합

Ready Queue : 현재 메모리 내에 있으면서 CPU를 잡아 실행되기를 기다리는 프로세스 집합

Device Queue : 디바이스 IO 작업을 대기하고 있는 프로세스의 집합



각각의 Queue에 프로세스들을 넣고 빼주는 스케줄러에도 크게 세 가지 종류가 존재한다.



## 장기 스케줄러

메모리는 한정되어 있는데 많은 프로세스들이 한꺼번에 메모리에 올라올 경우, 대용량 메모리에 임시로 저장됨.

이 풀에 저장되어 있는 프로세스 중 어떤 프로세스에 메모리를 할당해 Ready Queue에 보낼 지 결정한다.

- 메모리와 디스크 사이의 스케쥴링을 담당
- 프로세스에 메모리를 할당.
- Degree of Multiprogramming 제어
- 프로세스 상태 new -> ready (in memory)



## 단기 스케쥴러

- CPU와 메모리 사이의 스케쥴링 담당
- Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 작동 시킬지 결정
- 프로세스에 CPU를 할당
- 프로세스의 상태 ready -> running -> waiting -> ready



## 중기 스케쥴러

- 여유 공간을 마련하기 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄
- 프로세스에서 메모리를 Deallocate

- Degree of Multiprogramming 제어
- 프로세스의 상태 ready -> suspended







## CPU 스케줄러

스케줄링 대상은 Ready Queue에 있는 프로세스들이다.



### FCFS

- 먼저 온 순서대로 처리

- 비선점형 스케줄링

- 소요시간이 긴 프로세스가 먼저 도달해 효율성을 낮추는 형상이 발생.



### SJF(Shortest - Job - First)

- 다른 프로세스가 먼저 도착했어도 CPU burst time이 짧은 프로세스에게 선 할당

- 비선점형 스케줄링

  

- starvation : 효율성을 추구하는게 가장 중요하지만 특정 프로세스가 지나치게 차별을 받으면 안됨. 이 스케줄링은 극단적으로 CPU 사용이 짧은 잡을 선호한다. 사용 시간이 긴 프로세스는 영원히 CPU 를 할당 받을 수 없다.



### SRTF(Shortest Remaining Time First)

- 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이뤄진다.

- 선점형 스케줄링

- 현재 수행중인 프로세스의 남은 버스트 타임보다 더 짧은 CPU 버스트 타임을 가지는 프로세스가 도착하면 CPU를 뺏긴다.

  

- starvation

- 새로운 프로세스가 도달할 때마다 스케쥴링을 다시하기 때문에 CPU 버스트 타임을 측정할 수 없다.



### Priority Scheduling

- 우선순위가 가장 높은 프로세스에게 CPU 할당.
- 선점형 스케줄링 방식 : 더 높은 우선순위의 프로세스가 도착하며 ㄴ실행 중인 프로세스를 멈추고 CPU를 선점한다.
- 비선점형 스케쥴링 방식 : 더 높은 우선순위의 프로세스가 도착하면 Ready Queue의 Head에 넣는다.



- starvation
- 무기한 봉쇄 : 실행 준비는 되어 있으나 CPU를 사용 못하는 프로세스를 CPU가 무기한 대기하는 상태



- 해결책  aging: 아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여줌.





### Round Robin

#### 특징

- 현대적 CPU 스케쥴링 
- 각 프로세스는 동일한 크기의 할당 시간을 갖게 된다.
- 할당 시간이 지나면 프로세스는 선점당하고 ready queue를 제일 뒤에 가서 다시 줄을 선다.
- RR은 CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우 효율적
- RR이 가능한 이유는 프로세스의 context를 save할 수 있기 때문이다.



#### 장점

- Response time이 빨리짐.
- n개의 프로세스가 ready queue에 있고 할당시간이 q인 경우 각 프로세스는 q 단위로 CPU의 1/n을 얻는다. 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.

- 프로세스가 기다리는 시간이 CPU를 사용할 만큼 증가한다. 공정한 스케쥴링.



#### 주의 

- 설정한 time quatum이 너무 커지면 FCFS와 같아진다. 너무 작아지면 스케쥴링 알고리즘의 목적에는 이상적이지만 잦은 context switch로 오버헤드가 발생한다. 그렇기에 적당한 타임 퀀텀을 설정하는 것이 중요하다.

