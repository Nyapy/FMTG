# 자바의 상속

- 상속의 개념을 이해하고, 상속과 생성자의 관계를 설명할 수 있다.
- 변수에서의 상속과 상속되지 않는 멤버 변수의 종류를 구분하고, 메서드의 Overloading 과 Overriding을 구별할 수 있다.



## 상속

부모의 모든 것을 자식이 물려받음

즉 부모 클래스의 모든 변수와 메서드를 자식이 물려받음

왜 Inheritance 대신 extends를 쓸까??? 

=> 부모 클래스에서 추가로 확장한다는 개념이기 때문

상속 = 부모로부터 물려받은 공통적  특징 + 자식 클래스에서만 가지는 추가적 특징 

```java
class Employee{
    
}

class Manager extends Employee{
    
}
```



논리적으로 Is a 관계가 성립해야함

ex) 잉크젯 프린터는 프린터다, 레이저 프린터는 프린터다. 이런 느낌



여러 부모를 가지는 다중상속도 있으나,

**자바는 단일 상속만 허용** , 변수나 메서드가 중복되는 것을 방지 하기 위해 근본적으로 차단함



### 생성자 자동호출

상속된 클래스가 생성될 때 부모 클래스의 생성자도 자동으로 호출됨

그런데 부모 클래스 생성자 호출 후 자식 클래스 생성자가 호출된다.

다만 부모 클래스에 매개변수를 받는 생성자만 존재할 경우 부모 클래스에 기본 생성자가 없기 때문에 컴파일이 되지 않는다

```java
class A{
    public A(int num){
        System.out.println(num)
	}
}

class B extends A{
    public B(){ // ==>> 부모 클래스에 기본 생성자가 없기 때문에 컴파일 안됨
		System.out.println("Hi")
    }
}
```



### 부모 생성자 super()

부모 클래스의 생성자를 명시적 호출, 부모 클래스 생성자가 여러개일 경우 특정 생성자를 호출하기 위해 사용



```java
class shape{
    shape(){
        this(0.0)
	}
    shape(int x, int y){
        this.x = x;
        this.y = y;
    }
}
class circle extends shape{
    int radius;
    
    circle(int x, int y, int radius){
        super(x,y); //이렇게 사용
        this.radius = radius
    }
}
```



그런데 super() 생성자의 호출 위치는 반드시 자식 생성자의 첫 번째 위치에 존재해야 한다~!! 

부모 클래스의 생성자가 항상 자식 클래스 생성자보다 먼저 수행되어야 하기 때문에~!



## 상속과 멤버



자식 클래스 = 부모 클래스들이 가지고 있는 모든 멤버 + 자기 클래스에 선언된 모든 멤버



하지만!!

몇 가지 경우의 변수는 상속에서 제외

- private으로 정의된 변수는 상속 "불가"! => 해당 클래스 한정 사용 선언 이기 때문에.

- 자식 클래스에서 부모와 같은 이름의 변수로 선언 했다면, 덮어씌워지기 때문에 상속에서 지워짐~! (부모 클래스 변수를 자식에서 다시 클래스 변수로 선언하는 경우도 해당.)





### super 예약어

부모 객체의 변수에 접근할 수 있도록 도와줌

```java
class Emp{
    int depNo;
    String grade;
}
class Man extends Emp{
    char grade;
    
    void printGrade(){
        this.grade = 'A';
        super.grade = "A Grade";
    }
}

// 상속 안된다더니 왜 이렇게는 부를 수 있는지 모르겠다.
```





### 메서드의 상속

됨.



### 메서드 오버라이딩

부모 클래스 메서드를 재사용하지 않고 새롭게 정의하여 사용

자식 클래스가 부모 클래스의 메서드를 재정의 하여 사용하는 것.

걍 똑같이 적으면 덮어씌워짐



### 메서드 오버로딩

매개 변수의 타입, 개수가 다르면 오버라이딩 된것이 아니라 중복된 이름의 다른 메서드로 선언된 것이므로 오버로딩 된것임~!

ex)

print(String str)

print()

각각 부모 자식에 선언되었다면 오버로딩으로 선언된것



#### 메서드 오버로딩

- 하나의 클래스에 동일한 이름의 메서드가 여러개 중복 정의
- 메서드 매개변수의 개수나 타입이 달라야함

#### 메서드 오버라이딩

- 상속 관계에 있는 두 개의 클래스에서 부모가 가진 메서드와 동일한 시그니쳐를 가진 메서드가 자식 클래스에 재정의되어 있는것



#### 오버라이딩과 super 예약어

오버라이딩으로 걍 한 번 더 적기 

or

super 예약어로 불러와서 부모의 것을 그대로 불러오고 + 새로운 로직 수행



중복된 작업을 한다면 아래 것을 사용하는것도 ㄱㅊ



```java
public void takePicture(){
    super.takePicture();
    
    System.out.println("이런 느낌")
}
```





### 오버라이딩과 Fianl 예약어

Final 예약어는 변수, 메서드, 클래스 앞에 붙일 수 있는 Modifier

final + 변수 : 상수

final + Class : 자식 클래스를 가질 수 없는 클래스임을 의미

**final *+ 메서드 : 오버라이딩을 금지하는 의미***