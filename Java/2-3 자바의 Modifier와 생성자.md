# 2-3 자바의 Modifier와 생성자

- static 예약어, final 예약어, abstract 예약어의 기능을 이해,
- 생성자의 기능을 이해, this 예약어의 의미와 활용 방법 설명

## 1. 자바의 Modifier

### static 예약어

- 멤버 변수와 메서드 앞에 붙일 수 있는 모디파이어로, 활용방법을 제어함

static이 붙지 않는 경우 : 인스턴스 변수

- 생성된 인스턴스마다 그 안에 클래스의 인스턴스 변수들이 포함됨
- 일반적인 멤버 변수를 인스턴스 변수라함

static 예약어가 붙는 경우 : 클래스 변수

- 클래스로부터 생성된 인스턴스에 포함되지 않는 변수
- 많은 인스턴스를 생성해도 메모리에 하나의 변수만 존재함
- 객체를 생성하지 않고도 접근할 수 잇다...!



왜 클래스 변수가 필요할까?

- 동일한 값을 가지고 있는 변수를 인스턴스 변수로 선언하면 메모리가 낭비되기 때문



```java
class Employee {
    String name;
    int employeeNo;
    int age;
    static String companyName = "S전자";
}
//CompanyName은 인스턴스 변수에 포함되지 않음
```



#### 클래스 변수 접근

클래스 변수는 일반적으로 객체 참조 변수 이름으로 접근하기 보다는 클래스 이름을 통해 접근 

객체를 생성하지 않고도 접근 가능



#### 클래스 메서드

메서드에서도 static 예약어를 사용가능함

 클래스로부터 인스턴스를 생성하지 않고 호출 가능,

인스턴스 변수는 인스턴스 생성해야만 메모리가 잡히기 때문에 클래스 메서드에서 사용이 불가 => 클래스 메서드에서는 클래스 변수만 호출 가능



### final 예약어

final이 붙은 변수는 단 한 번 초기화가 가능하지만, 초기화 이후에는 값을 변경할 수 없는 상수.

클래스 변수의 값을 변경할 수 있도록 허용하는 경우 static 예야갸어의 의미가 상실되므로 final과 결합하여 사용해 변경할 수 없게 할 수 있음

```java
final static String var = "hi";
static final String var = "hi";
//둘다 괜찮은듯
```

#### 메서드와 final

메서드재정의 (오버라이딩): 상속구조에서 부모클래스의 메서드와 동일한 모양의 메서드를 자식 클래스에서 상속받지 않고 새롭게 정의가 가능

다만 부모 클래스에서 final로 선언한다면 자식 클래스에서 변경 불가



#### 클래스와 final

클래스를 선언할때 클래스 앞에 final예약어를 추가하면 상속을 금지하는 의미이다.

즉 자식 클래스를 가지지 못하는 클래스가 된다. => 상속금지를 의미





### 추상 메서드

#### abstract

클래스와 메서드를 선언할때 사용하는 모디파이어

메서드, 클래스 선언시 abstract를 붙이면 추상 메서드, 추상 클래스로 선언된다.



#### 추상메서드

 메서드의 시그니처(리턴 타입, 메서드명, 매개변수)만 정의되고 구체적인 행위, 즉 블록부분은 정의되지 않는 메서드를 의미함

```java
abstract int sum(int num1, int num2);
```



#### 추상클래스

추상 메서드를 포함하고 있는 클래스는 추상 클래스로 선언되어야 한다, 추상 클래스가 추상 메서드를 포함하지 않을 수도 있음(걍 메서드만 가지고 있을 수도 있음)



대체 왜 이걸 지원하는 것일까??

추상 클래스와 상속이 결합되어야 이해할 수 있음

```java
abstract class SuperClass{
    public void methodA(){
        System.out.prinln("methodA() 실행")
    }
    public abstract void methodB();
}



class subClass extends SuperClass{
    public void methodB(){
        System.out.prinln("methodB() 실행")
    }
} //자식 클래스인 서브클래스가 수퍼클래스를 상속

//이런 경우 추상메서드를 포함하려면 추상클래스가 되어야하므로, 메서드B를 오버라이딩 시켜야함
```





## 생성자

생성자는 클래스로부터 객체를 생성할때 호출되며 객체 멤버 변수를 초기화 하는데 사용되는 메서드임.

객체를 생성할때 객체에 필요한 값들을 초기화하는 개념은 배열과 동일



- 생성자는 클래스와 같은 이름을 가진 특별한 메서드, 객체 생성 시 멤버 변수의 초기화 담당
- 일반 멤버 메서드와 달리 반환형이 없다 (void도 허용되지 않음)
- 생성자는 이름은 같지만 매개변수를 달리해 여러 개의 중복정의(오버라이딩) 할 수 있다.
- 생성자는 키워드 new와 항상 같이 사용된다.
- 명시적으로 작성하지 않으면 기본 생성자가 제공된다.



생성자를 선언하는 방법

```java
[access modifier] class명 ([argument list]){
}
```



기본 생성자 => 클래스에 생성자가 하나도 정의되지 않은 경우 자동으로 생성되는 생성자

생성된 객체의 멤버 변수 일정규칙에 따라 초기화





#### 생성자 자동생성

클래스 생성 , 변수 선언 후

Alt shift S 눌러 팝업 메뉴 제시해서 

제너레이트 컨스트럭터 유징필드 눌러서 생성하면 됨





### this의 의미

생성자나 메서드의 매개변수 이름이 객체 변수의 이름과 같다면?

=>  객체 변수 이름 앞에 this를 사용해서 구별

```java
public class Employee{
    String name;
    int number;
    
    public Employee(String name, int age){
        name = name;
        age = age;
    }
    //변수 명이 같아 멤버 변수에 할당 불가
}
그래서 this.name = name;
this.age = age 로 바꿔줘야함
```

