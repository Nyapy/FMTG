# Tree

트리는 비선형 자료구조이다. 계층적 관계를 표현하는 자료 구조이다.

Node : 트리를 구성하고 있는 요소

Edge : 노드와 노드를 연결하는 선.

Root Node : 최상위 노드

Terminal Node : 하위에 다른 노드가 연결되어 있지 않는 끄트머리 노드

Internal Node : 단말 노드를 제외한 나머지 노드(루트 포함)





## 트리의 순회(Traversal)



## Binary Tree(이진트리)

루트 노드가 두 개의 서브 트리를 가진다. 두 서브 트리 역시 이진 트리를 가진다. 공집합 또한 이진 트리. 재귀적 정의.

트리의 각 층별로 숫자를 매겨 이를 레벨 이라고 한다. 레벨은 0부터 시작하고 트리의 최고 레벨을 높이 라고 한다.

Perfect Binary Tree, Complete Binary Tree, Full Binaly Tree

모든 레벨이 꽉 찬 이진트리를 포화 이진 트리라고 한다. 모든 노드가 0개 혹은 2개의 자식 노드를 갖는 이진 트리이다.





## Binary Search Tree(BST, 이진탐색트리) 

효율적인 탐색을 위한 저장방법을 사용한 트리, 이진 트리의 일종으로 데이터를 저장하는 규칙이 있다.

이진탐색과 Linked list를 결합한 자료구조.

1. 이진 탐색 트리의 노드에 저장된 키가 유일하다.
2. 부모의 키가 왼쪽 자식 노드의 키보다 크다.
3. 부모의 키가 오른쪽 자식 노드의 키보다 작다.
4. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.

이진 탐색 트리의 탐색 연산은 O(log n)의 복잡도를 갖는다. 정확히는 O(height)가 맞다. 높이를 하나씩 더해갈 수록 추가할 수 있는 노드 수가 두 배가 되기 때문에. 하지만 이런 이진 트리는 편향 트리가 될 수 있다. 한 쪽으로만 노드가 추가되는 상황이 발생하기 때문에.

배열보다 많은 메모리를 사용하며 데이터를 저장하지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생하므로 이를 해결하기 위한 Rebalancing 기법이 존재한다. 이 기법을 구현한 트리는 여러 종류가 있는데 대표적인 것이 Red-Black Tree



## Binary Heap 

자료 구조의 일종으로 Tree 형식을 하고 있으며, Tree 중에서도 배열에 기반한 완전 이진 트리이다. 배열에 트리 값을 넣어줄 때 0을 건너뛰고 1번 인덱스부터 루트가 시작한다. 노드 교유번호와 배열의 인덱스를 일치시켜 혼동을 줄이기 위함. 힙에는 최대힙과 최소힙 두 종류가 있다.

힙을 활용하는 2가지 예는 우선순위 큐의 구현과 정렬이다.

Priority Queue는 바이너리 힙을 사용해 만들 수는 있지만 직접적 연관은 없음. 기능에 있어서도 힙을 이용해 만드는 것이 효과적이므로 거의 동일어나 다름없이 혼용되고 있다. 우선순위 큐를 구현하는 가장 효율적인 방법이 힙을 사용하는 것.

### 힙의 삽입, 삭제

#### 삽입

1. 힙의 끝자리에 키를 삽입한다. 2. 부모와 비교해 특성을 위배한다면 자리를 바꾼다. 3. 이걸 반복한다.

#### 삭제

힙에서는 루트 노드의 원소만을 삭제할 수 있다. 이때 루트 노드의 반환값으로 최대값, 또는 최솟값을 구할 수 있다.

삭제 과정:

1. 루트의 원소 삭제, 2. 마지막 리프노드를 루트로 바꿈, 3. 오른쪽 자식과 비교하여 특성 위배시 자리를 바꾼다.



## Red-Black Tree

BST를 기반으로 하는 트리 형식의 자료구조. 삽입, 삭제에서 생기는 문제점을 해결하기 위해 만들어진 자료구조

탐색, 삽입, 삭제에 O(log n)의 시간 복잡도가 소요된다. 

높이를 최소화하여 시간 복잡도를 줄이는 것이 핵심 아이디어, 

### 성질은 다음과 같다.

1. 각 노드는 Red or Black의 색을 갖는다
2. Root node의 색은 Black
3. Leaf node의 색도 Black
4.  어떤 노드의 색이 Red이면 두 개의 자식노드는 모두 Black
5. 각 노드에 대해 노드로부터 자손 리프 노드까지 단순 경로는 모두 같은 수의 Black node들을 포함하고 있다. 이를 해당 노드의 Black-Height라고 한다.

### 특징 

1. BST의 특징을 모두 갖는다.
2. Root node부터 leaf 노드까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율이 2보다 크지 않다. 이런 상태를 balanced라고 한다.
3. 노드의 자식이 없을 경우 자식을 가리키는 포인터는 NIL 값을 저장한다. NIL들은 리프 노드로 간주한다.



### 삽입, 삭제의 문제점을 어떻게 해결하는가?

#### 삽입

우선 BST의 성질을 유지하며 노드 삽입, 상입된 노드의 색을 RED로 지정한다. 그 이유는 black-height을 최소화 하기 위해. 사입 결과 BST의 특성 위배시 노드색을 조정하고 Black-height가 위배되었다면 rotation 을 통해 height를 조정한다. 

이런 과정을 통해 RBT의 동일한 height에 존재하는 internal node들의 black-height가 같아지게 되고 최소 경로와 최대 경로의 크기 비율이 2미만으로 유지된다.

#### 삭제 

삭제도 삽입과 마찬가지로 BST의 특성을 유지하며 해당 노드를 삭제, 삭제될 노드의 자식 수에 따라 rotation 방법이 달라진다. 만약 지워진 노드의 색이 Black이라면 Black-height가 1감소한 경로에 black 노드가 1개 추가되도록 rotation, 노드의 색을 조정. 지워진 노드의 색이 red라면 Violation 이 발생하지 않으므로 RBT 가 그대로 유지.

c++의 Map 구조에서 사용된다. Hash map에서 separate chaning에서도 사용된다.



RBT 뭔 말인지 모르겠네.