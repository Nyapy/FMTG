# 자바 프로그램 기초

- 자바 프로그램은 하나의 .java 파일에 하나의 클래스를 정의

- 클래스 내부에 실행에 필요한 변수나 메서드 등을 정의

``` java
public class FirstClass{
    // public은 자바 예약어로 FirstClass.java를 외부에 공개함
}
```



클래스의 의미 

- 자바 프로그램의 최소 구성 단위, 선언된 클래스 내부에 실행에 필요한 변수나 메서드 등이 정의됨



## 주석

주석의 종류에는 3가지가 있음

/* */ => 다중행 주석

// => 단일행 주석

/**  */ => javadoc 주석, javadoc 파일명.java  명령어 실행시 javadoc 주석문 내용과 코드설명이 html 문서로 제공



## 자바 애플리케이션 구조

- 자바 애플리케이션은 바이트 코드로 번역된 후 바로 실행할 수 있는 일반 프로그램
- 반드시 main 메서드를 가지고 있어야함

https://chans-note.tistory.com/1 참고



## 자바 출력 문장

java.io 패키지 : 처리하기 어려운 입출력 작업을 효율적으로 지원하기 위해 java.io 패키지 제공, 입출력 프로그램 구현

```java
System.outprintln("Hello World!");
```



## 식별자와 예약어

식별자 : 클래스, 변수, 메서드에 주어지는 이름, 각 요서의 식별을 가능하게 함.

1. 첫 문자는 A-Z, a-z, 유니코드로 시작

2. 특수문자 불가
3. 대소문자 구별, 길이제한 X
4. 예약어 포함 가능하나 예약어만을 사용할 수는 없음
5. 숫자를 사용할 수 없으나 첫 문자에 숫자 사용 불가,

관례상 클래스 이름은 대문자, 메서드 이름은 소문자, 변수는 소문자, 상수는 대문자로 시작



예약어 : 시스템에 일정 특성을 가진 언어로 등록된 것, 데이터 타입이나 프로그램 정의를 위해 사용됨.



## 데이터 타입과 변수

프로그램 언어에서는 사용할 데이터를 변수에 저장하고 관리, 정의되 ㄴ변수를 통해 데이터 의미를 정확하게 해석하여 사용

bit : 0과 1로 구분되는 데이터 표현의 가장 기본 단위

byte : bit가 8개 모이면 1byte가 되어 하나의 문자를 표현함.(2의 8승만큼 가질 수 있음 256)



논릿값 boolean

단일 문자 char

- 논릿값

  - boolean 참, 거짓

    true or false

- 단일 문자

  - char 16비트 유티코드 문자 데이터'

    하나의 문자는 char형으로 표현, char형 리터럴은 홑따옴표 안에 넣어야함

    16비트 유니코드 문자로 표현됨, 비영어권 고려('\u0000' ~ '\uffff')

- 정수 (10진수, 8진수, 16진수 사용())

  0이 아닌 정수로 시작하면 10진수, 0으로 시작하면 8진수 , 0x로 시작하면 16진수

  - byte 부호가 있는 8비트
  - short 부호 있는 16비트 정수
  - int 부호 있는 32비트의 정수
  - long 부호 있는 64비트의 정수

  부호형은 맨 앞자리가 0이면 양수값, 1이면 음수 

- 실수

  - float 부호가 있는 32비트 부동소수점 실수
  - double 부호가 있는 64비트 부동소수점 실수

  실수형 중 형을 명시하지 않으면 double이 기본형으로 정의됨.

참고 literal : 각 자료형에서 사용할 수 있는 데이터 값을 의미, https://dololak.tistory.com/676



데이터 타입 범위 초과시 발생하는 경우

- 변수 초기화시 타입의 범위를 초과하는값 입력
- 연산결과로 값의 범위를 초과하는 경우



## 변수 및 변수 선언

프로그래머가 메모리상의 데이터에 접근하기 위한 방법

한 가지 유형의 데이터만을 저장, 각 변수가 저장할 수 있는 데이터 유형이 정해져있음

데이터가 필요로하는 크기의 메모리 할당을 위해 데이터 타입 명시

데이터 타입 변수명;

```java
int var;  //변수 선언
var = 25; //변수 초기화

int var = 25; //이렇게도 처리 가능

//예시
int age;
age = 25;
//age라는 인트 변수 선언시 4바이트 메모리가 할당, 변수 age에 25를 할당하면 25가 할당된 메모리에 저장됨.
```



자동 초기화 :

byte, short, int : 0

long : 0L

float : 0.0f

double : 0.0D

char : '\u0000' (null)

boolean : false

참조형 : null

```java
public class AssignTest{
    public static void main(String args[]){
        int x, y ;
        float z = 3.414f;
        double w = 3.1415;
        boolean truth = true;
        char c;
        String str;
        String str1 = "bye";
        c = 'A';
        str = "Hi out there!";
        x = 6;
        y = 1000;
    }
}
```



## 지역 변수, 전역 변수

전역 변수

- 클래스 선언부 밑에 선언된 변수

- 여러 메서드에서 공통으로 사용가능

지역 변수

- 메서드 선언부 밑에 선언된 변수
- 메서드 매개변수로 선언된 변수
- 해당 변수가 선언된 메서드 내에서만 사용가능



변수는 자신이 속한 블록 {}을 벗어나면 사용 불가

```java
		if (true){
			int x = 5;
			
		}
			System.out.println(x);
// 이거 에러남 .
```



## 데이터 타입의 변환 = 형변환

### 묵시적 형변환

작은 데이터 타입 => 큰 데이터 타입 : 묵시적 형변환(프로모션) 데이터 손실 우려가 없어 자동으로 해줌

```java
int age = 25;
double avgAge = age;
double avgAge = (double)age;
//형 변환 연산자를 생략할 수 있음 (ㅁㄱ시적)
// byte => short => int => long => float => double
// char => int => long => float => double
```

```java
		byte b1 = 127;
		char c1 = '가';
		int i1;
		double d1;
		System.out.println("자동 형변환 결과");
		i1 = b1;
//바이트를 인트 형으로 형변환한 경우로서 127이 1바이트에서 4바이트로 표현됨
		System.out.println("i1 = b1의 형변환 " + i1);
		i1 = c1;
// char의 가를 int형으로 형 변환하면 가를 유니코드로 표현한 십진수 값 44032이 인트 데이트 i1에 저장됨
		System.out.println("i1 = c1의 형변환 " + i1);
		d1 = i1;
//인트 데이터를 더블로 형변환하면 정수가 실수로 형변환 되어 i1에 저장되었던 44032가 44032.0의 8바이트 실수로 전환되어 저장
		System.out.println("d1 = i1의 형변환 " + d1);
```



### 명시적 형변환

큰 데이터 타입 => 작은 데이터 타입 : 명시적 형변환(디모션) 데이터 손실의 우려로 명시적으로 함

```java
double avgAge = 24.35;
int age = (int)avgAge;
```

데이터 타입이 축소되어도 해당값을 표현할 수 있어야 함, 안그러면 전혀 다른 값을 가지게 된다

```java
int sum = 128;
byte data = (byte)sum;
//바이트가 가지는 범위 -127 ~ 128
//4바이트로 표현된 128을 1바이트로 축소하여 형 변환
// b변수가 바이트 범위 밖의 128을 올바르게 표현할 수 없음
```



```java
		byte b1 = 127;
		char c1;
		int i1 = 128;
		int i2 = 97;
		double d1 = 3.14;
		System.out.println("명시적 형변환 결과");
		b1 = (byte)i1;
// 인트 데이터는 바이트형으로 형변환했을때 바이트는 128을 표현할 수 없으므려 전혀다른값 -128을 저장
		System.out.println("b1 = i1의 형변환 " + b1);
		c1 = (char)i2;
// 97이라는 인트 데이터를 char 형으로 형변환 했을 때 97을 유니코드로 하는 문자인 소문자 a가 c1에 저장
		System.out.println("c1 = i2의 형변환 " + c1);
		i1= (int)d1;
// int double 데이터를 int 데이터로 명시적 형변환하여 3.15 소수점 아래를 제외한 정수 부분만을 i1 변수에 저장
		System.out.println("d1 = i1의 형변환 " + i1);
```

